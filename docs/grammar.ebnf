(* ============================================================================ *)
(* Intent Programming Language -- Formal Grammar                               *)
(* Version: 0.1.0 (Proof of Concept)                                          *)
(*                                                                             *)
(* Notation:                                                                   *)
(*   =          definition                                                     *)
(*   ,          concatenation                                                  *)
(*   |          alternation                                                    *)
(*   [ ... ]    optional (zero or one)                                         *)
(*   { ... }    repetition (zero or more)                                      *)
(*   ( ... )    grouping                                                       *)
(*   "..."      terminal string (keyword or symbol)                            *)
(*   '...'      terminal string (alternate quoting)                            *)
(*   (* ... *)  comment                                                        *)
(*   ;          end of production rule                                         *)
(* ============================================================================ *)


(* -------------------------------------------------------------------------- *)
(* Top-Level Structure                                                         *)
(* -------------------------------------------------------------------------- *)

program = module_decl , { top_level_decl } ;

module_decl = "module" , identifier , "version" , string_literal , ";" ;

top_level_decl = function_decl
               | entity_decl
               | intent_block ;


(* -------------------------------------------------------------------------- *)
(* Function Declarations                                                       *)
(* -------------------------------------------------------------------------- *)

function_decl = [ "entry" ] , "function" , identifier ,
                "(" , [ param_list ] , ")" ,
                "returns" , type_ref ,
                { requires_clause } ,
                { ensures_clause } ,
                block ;

param_list = param , { "," , param } ;

param = identifier , ":" , type_ref ;

requires_clause = "requires" , expression ;

ensures_clause = "ensures" , expression ;


(* -------------------------------------------------------------------------- *)
(* Entity Declarations                                                         *)
(* -------------------------------------------------------------------------- *)

entity_decl = "entity" , identifier , "{" , { entity_member } , "}" ;

entity_member = field_decl
              | invariant_decl
              | constructor_decl
              | method_decl ;

field_decl = identifier , ":" , type_ref , ";" ;

invariant_decl = "invariant" , expression , ";" ;

constructor_decl = "constructor" , "(" , [ param_list ] , ")" ,
                   { requires_clause } ,
                   { ensures_clause } ,
                   block ;

method_decl = "method" , identifier , "(" , [ param_list ] , ")" ,
              "returns" , type_ref ,
              { requires_clause } ,
              { ensures_clause } ,
              block ;


(* -------------------------------------------------------------------------- *)
(* Intent Blocks                                                               *)
(* -------------------------------------------------------------------------- *)

intent_block = "intent" , string_literal , "{" , { intent_clause } , "}" ;

intent_clause = goal_clause
              | constraint_clause
              | guarantee_clause
              | verified_by_clause ;

goal_clause = "goal" , string_literal , ";" ;

constraint_clause = "constraint" , string_literal , ";" ;

guarantee_clause = "guarantee" , string_literal , ";" ;

verified_by_clause = "verified_by" , verified_by_path , ";" ;

verified_by_path = identifier , { "." , identifier } ;


(* -------------------------------------------------------------------------- *)
(* Statements                                                                  *)
(* -------------------------------------------------------------------------- *)

block = "{" , { statement } , "}" ;

statement = let_statement
          | assign_statement
          | return_statement
          | if_statement
          | expression_statement ;

let_statement = "let" , [ "mutable" ] , identifier , ":" , type_ref ,
                "=" , expression , ";" ;

assign_statement = assign_target , "=" , expression , ";" ;

assign_target = identifier
              | "self" , "." , identifier ;

return_statement = "return" , [ expression ] , ";" ;

if_statement = "if" , expression , block , [ else_clause ] ;

else_clause = "else" , ( if_statement | block ) ;

expression_statement = expression , ";" ;


(* -------------------------------------------------------------------------- *)
(* Expressions                                                                 *)
(*                                                                             *)
(* Precedence levels (lowest to highest):                                      *)
(*   1. implies       (right-associative)                                      *)
(*   2. or            (left-associative)                                       *)
(*   3. and           (left-associative)                                       *)
(*   4. not           (prefix, unary)                                          *)
(*   5. == !=         (left-associative)                                       *)
(*   6. < > <= >=     (left-associative)                                       *)
(*   7. + -           (left-associative)                                       *)
(*   8. * / %         (left-associative)                                       *)
(*   9. - (unary)     (prefix, unary)                                          *)
(*  10. . () (access) (left-associative, postfix)                              *)
(* -------------------------------------------------------------------------- *)

expression = implies_expr ;

implies_expr = or_expr , [ "implies" , implies_expr ] ;
(* Right-associative: a implies b implies c = a implies (b implies c) *)

or_expr = and_expr , { "or" , and_expr } ;

and_expr = not_expr , { "and" , not_expr } ;

not_expr = "not" , not_expr
         | equality_expr ;

equality_expr = comparison_expr , { ( "==" | "!=" ) , comparison_expr } ;

comparison_expr = additive_expr , { ( "<" | ">" | "<=" | ">=" ) , additive_expr } ;

additive_expr = multiplicative_expr , { ( "+" | "-" ) , multiplicative_expr } ;

multiplicative_expr = unary_expr , { ( "*" | "/" | "%" ) , unary_expr } ;

unary_expr = "-" , unary_expr
           | postfix_expr ;

postfix_expr = primary_expr , { postfix_op } ;

postfix_op = "." , identifier , [ "(" , [ arg_list ] , ")" ]
           | "(" , [ arg_list ] , ")" ;
(* The first alternative handles both field access (no parens) and method calls (with parens). *)
(* The second alternative handles bare function calls on an identifier primary. *)
(* Note: Function calls are: identifier followed by postfix_op "(" args ")".    *)
(*       Method calls are: expr "." identifier "(" args ")".                     *)
(*       Field access is: expr "." identifier (no parens).                       *)

arg_list = expression , { "," , expression } ;

primary_expr = int_literal
             | float_literal
             | string_literal
             | bool_literal
             | "self"
             | "result"
             | "old" , "(" , expression , ")"
             | identifier
             | "(" , expression , ")" ;


(* -------------------------------------------------------------------------- *)
(* Types                                                                       *)
(* -------------------------------------------------------------------------- *)

type_ref = "Int"
         | "Float"
         | "String"
         | "Bool"
         | "Void"
         | identifier ;
(* The identifier alternative covers entity types. *)
(* The semantic checker distinguishes built-in types from entity types. *)


(* -------------------------------------------------------------------------- *)
(* Literals                                                                    *)
(* -------------------------------------------------------------------------- *)

int_literal = digit , { digit } ;

float_literal = digit , { digit } , "." , digit , { digit } ;

string_literal = '"' , { string_char } , '"' ;

string_char = (* any character except '"' and '\' *)
            | escape_sequence ;

escape_sequence = '\"'
               | '\\'
               | '\n'
               | '\t'
               | '\r' ;

bool_literal = "true" | "false" ;


(* -------------------------------------------------------------------------- *)
(* Identifiers                                                                 *)
(* -------------------------------------------------------------------------- *)

identifier = ( letter | "_" ) , { letter | digit | "_" } ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
       | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
       | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
       | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
       | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;


(* -------------------------------------------------------------------------- *)
(* Comments (lexical, not part of the grammar proper)                          *)
(*                                                                             *)
(* Line comment:  // ... (extends to end of line)                              *)
(* Block comment: /* ... */ (does not nest)                                    *)
(*                                                                             *)
(* Comments are stripped by the lexer and do not appear in the parse tree.     *)
(* -------------------------------------------------------------------------- *)
