module attractor_retry version "0.1.0";

import "types.intent";

public function build_retry_policy(node_max_retries: Int, graph_default_max_retry: Int) returns RetryPolicy
    requires graph_default_max_retry >= 0
    ensures result.max_attempts >= 1
{
    let mutable chosen: Int = graph_default_max_retry;
    if node_max_retries > 0 { chosen = node_max_retries; }
    return RetryPolicy(chosen + 1, 200, 2.0, 60000);
}

public function standard_policy() returns RetryPolicy
    ensures result.max_attempts == 5
{
    return RetryPolicy(5, 200, 2.0, 60000);
}

public function aggressive_policy() returns RetryPolicy
{
    return RetryPolicy(5, 500, 2.0, 60000);
}

public function linear_policy() returns RetryPolicy
    ensures result.backoff_factor == 1.0
{
    return RetryPolicy(3, 500, 1.0, 60000);
}

public function patient_policy() returns RetryPolicy
{
    return RetryPolicy(3, 2000, 3.0, 60000);
}

public function no_retry_policy() returns RetryPolicy
    ensures result.max_attempts == 1
{
    return RetryPolicy(1, 0, 1.0, 0);
}

// Calculate delay in ms for a given retry attempt (1-indexed).
// Uses integer doubling since Intent does not support Int*Float mixed arithmetic.
// Exact for standard/aggressive policies (factor=2.0).
public function delay_for_attempt(attempt: Int, policy: RetryPolicy) returns Int
    requires attempt >= 1
    requires policy.max_attempts >= 1
    ensures result >= 0
    ensures result <= policy.max_delay_ms
{
    let mutable delay: Int = policy.initial_delay_ms;
    let mutable i: Int = 1;
    while i < attempt {
        delay = delay * 2;
        i = i + 1;
    }
    if delay > policy.max_delay_ms { delay = policy.max_delay_ms; }
    return delay;
}

public function should_retry(status: StageStatus) returns Bool
{
    let val: Bool = match status { Retry => true, _ => false, };
    return val;
}

public function is_retriable(status: StageStatus, attempt: Int, max_attempts: Int) returns Bool
    requires attempt >= 1
    requires max_attempts >= 1
{
    let retryable: Bool = match status { Retry => true, _ => false, };
    return retryable and attempt < max_attempts;
}

public function goal_gate_satisfied(status: StageStatus) returns Bool
{
    let val: Bool = match status { Success => true, PartialSuccess => true, _ => false, };
    return val;
}

public function max_with_partial(allow_partial: Bool) returns StageStatus
{
    if allow_partial { return PartialSuccess; }
    return Fail;
}

intent "Retry policy correctness" {
    goal: "Retry policies enforce Attractor spec Section 3.5-3.6 behavior";
    guarantee: "Backoff delays never exceed max_delay_ms and attempts never exceed max_attempts";
    verified_by: [delay_for_attempt.ensures, build_retry_policy.ensures, is_retriable.requires];
}
